<!doctype html>
<html lang="zh-HK">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ç«‹é«”åœ–å½¢é…å°é€šé—œ</title>
  <style>
    :root{
      --bg:#f6f7fb; --card:#fff; --ink:#1b1f2a; --muted:#6b7280;
      --line:#e5e7eb; --good:#16a34a; --bad:#dc2626; --accent:#2563eb;
    }
    body{ margin:0; font-family: "Noto Sans TC","PingFang TC","Microsoft JhengHei",system-ui,sans-serif; background:var(--bg); color:var(--ink); }
    header{ padding:16px 18px; background:#fff; border-bottom:1px solid var(--line); }
    header h1{ margin:0; font-size:18px; }
    header p{ margin:6px 0 0; color:var(--muted); font-size:13px; line-height:1.4; }

    .wrap{ max-width:1100px; margin:0 auto; padding:16px 18px 28px; }
    .top{
      display:grid; grid-template-columns: 1.1fr 1.9fr; gap:14px; align-items:start;
    }
    .panel{ background:var(--card); border:1px solid var(--line); border-radius:14px; box-shadow:0 8px 24px rgba(0,0,0,.06); }
    .panel .hd{ padding:12px 14px; border-bottom:1px solid var(--line); display:flex; justify-content:space-between; align-items:center; gap:10px; }
    .panel .hd .meta{ font-size:13px; color:var(--muted); }
    .panel .bd{ padding:12px 14px; }
    #canvasWrap{ height:360px; }
    canvas{ display:block; width:100%; height:100%; border-radius:12px; }

    .controls{ display:flex; gap:8px; flex-wrap:wrap; }
    button{
      border:1px solid var(--line); background:#fff; padding:10px 12px; border-radius:12px;
      font-size:14px; cursor:pointer;
    }
    button.primary{ background:var(--accent); color:#fff; border-color:transparent; }
    button:disabled{ opacity:.5; cursor:not-allowed; }

    .status{
      margin-top:10px; padding:10px 12px; border-radius:12px;
      border:1px dashed var(--line); color:var(--muted); font-size:14px; line-height:1.5;
    }
    .status.good{ border-color:rgba(22,163,74,.35); background:rgba(22,163,74,.07); color:#0f5f2b; }
    .status.bad{ border-color:rgba(220,38,38,.35); background:rgba(220,38,38,.07); color:#7f1d1d; }

    .grid{
      display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:12px;
    }
    .group{ padding:12px 12px 14px; }
    .group h3{ margin:0 0 8px; font-size:14px; color:#111827; }
    .opts{ display:flex; flex-wrap:wrap; gap:8px; }
    .opt{
      padding:10px 10px; border-radius:12px; border:1px solid var(--line); background:#fff;
      font-size:14px; cursor:pointer; user-select:none;
    }
    .opt.selected{ outline:2px solid rgba(37,99,235,.35); border-color:rgba(37,99,235,.55); }
    .opt.locked{ opacity:.75; cursor:not-allowed; }

    .footerRow{
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      padding:12px 14px; border-top:1px solid var(--line);
    }
    .score{ font-size:13px; color:var(--muted); }
    .hint{ font-size:13px; color:var(--muted); }
    @media (max-width:900px){
      .top{ grid-template-columns: 1fr; }
      #canvasWrap{ height:320px; }
    }
  </style>
</head>
<body>
<header>
  <h1>ç«‹é«”åœ–å½¢é…å°é€šé—œï¼ˆè§’éŒï¼è§’æŸ±ï¼‰</h1>
  <p>æ¯é—œå…ˆç‡ 3D åœ–å½¢ï¼Œç„¶å¾Œå–ºå››é¡å­—å¡å„æ€ä¸€å¼µã€‚å››é¡å…¨éƒ¨æ­£ç¢ºå…ˆç®—é€šé—œã€‚</p>
</header>

<div class="wrap">
  <div class="top">
    <!-- å·¦ï¼š3D -->
    <div class="panel">
      <div class="hd">
        <div>
          <div style="font-weight:700;">3D ç«‹é«”åœ–å½¢</div>
          <div class="meta" id="shapeMeta">è¼‰å…¥ä¸­â€¦</div>
        </div>
        <div class="controls">
          <button id="btnNew">ä¸‹ä¸€é¡Œ</button>
          <button id="btnReset">é‡è¨­é¸æ“‡</button>
        </div>
      </div>
      <div class="bd">
        <div id="canvasWrap" class="panel" style="border:none; box-shadow:none;">
          <canvas id="c"></canvas>
        </div>
        <div id="status" class="status">æç¤ºï¼šç”¨æ»‘é¼ æ‹–æ‹‰å¯æ—‹è½‰ï¼Œæ»¾è¼ªå¯ç¸®æ”¾ï¼ˆæ‰‹æ©Ÿå¯å–®æŒ‡æ‹–æ‹‰ï¼‰ã€‚</div>
      </div>
    </div>

    <!-- å³ï¼šå­—å¡ -->
    <div class="panel">
      <div class="hd">
        <div style="font-weight:700;">å››é¡å­—å¡é…å°</div>
        <div class="meta">æ¯é¡æ€ 1 å¼µ â†’ æäº¤</div>
      </div>

      <div class="bd">
        <div class="grid">
          <div class="panel group">
            <h3>A é¡ï¼šæŸ±é«”ï¼éŒ</h3>
            <div class="opts" id="groupA"></div>
          </div>
          <div class="panel group">
            <h3>B é¡ï¼šå´é¢å½¢ç‹€</h3>
            <div class="opts" id="groupB"></div>
          </div>
          <div class="panel group">
            <h3>C é¡ï¼šç¸½é¢æ•¸</h3>
            <div class="opts" id="groupC"></div>
          </div>
          <div class="panel group">
            <h3>D é¡ï¼šåå­—</h3>
            <div class="opts" id="groupD"></div>
          </div>
        </div>
      </div>

      <div class="footerRow">
        <div class="score" id="score">å·²é€šé—œï¼š0ã€€ï½œã€€ç¸½é¡Œæ•¸ï¼š0</div>
        <div style="display:flex; gap:8px; align-items:center;">
          <span class="hint" id="pickHint">å°šæœªæäº¤</span>
          <button class="primary" id="btnSubmit" disabled>æäº¤</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Three.js -->
<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

<script>
/** =========================
 *  è³‡æ–™èˆ‡è¦å‰‡
 *  ========================= */
const POLY_N = [3,4,5];
const TYPES = ["pyramid","prism"]; // è§’éŒ / è§’æŸ±

function shapeName(n, type){
  // ä¸‰è‡³äº”è§’éŒ / ä¸‰è‡³äº”è§’æŸ±
  const map = {3:"ä¸‰",4:"å››",5:"äº”"};
  return map[n] + (type==="pyramid" ? "è§’éŒ" : "è§’æŸ±");
}

function isPyramid(type){ return type==="pyramid"; }
function facesCount(n, type){
  return isPyramid(type) ? (n + 1) : (n + 2);
}
function lateralFaceLabel(type){
  return isPyramid(type) ? "å®ƒçš„å´é¢æ˜¯ä¸‰è§’å½¢" : "å®ƒçš„å´é¢æ˜¯å››é‚Šå½¢";
}
function solidTypeLabel(type){
  return isPyramid(type) ? "å®ƒæ˜¯éŒ" : "å®ƒæ˜¯æŸ±é«”";
}

/** =========================
 *  å°å·¥å…·
 *  ========================= */
function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}
function sampleOne(arr){
  return arr[Math.floor(Math.random()*arr.length)];
}
function uniquePush(arr, item){
  if(!arr.includes(item)) arr.push(item);
}

/** =========================
 *  éŠæˆ²ç‹€æ…‹
 *  ========================= */
let current = null; // {n, type}
let selected = {A:null,B:null,C:null,D:null};
let cleared = 0;
let total = 0;

const els = {
  meta: document.getElementById("shapeMeta"),
  status: document.getElementById("status"),
  score: document.getElementById("score"),
  pickHint: document.getElementById("pickHint"),
  submit: document.getElementById("btnSubmit"),
  newBtn: document.getElementById("btnNew"),
  resetBtn: document.getElementById("btnReset"),
  groupA: document.getElementById("groupA"),
  groupB: document.getElementById("groupB"),
  groupC: document.getElementById("groupC"),
  groupD: document.getElementById("groupD"),
};

/** =========================
 *  3D å ´æ™¯
 *  ========================= */
const canvas = document.getElementById("c");
const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
camera.position.set(3.2, 2.2, 3.2);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.06;

scene.add(new THREE.AmbientLight(0xffffff, 0.85));
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(4,6,3);
scene.add(dir);

// åœ°å°
const ground = new THREE.Mesh(
  new THREE.CircleGeometry(2.2, 64),
  new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.95, metalness:0.0})
);
ground.rotation.x = -Math.PI/2;
ground.position.y = -0.9;
scene.add(ground);

// ç›®å‰æ¨¡å‹
let mesh = null;

function makePrism(n){
  // ç”¨ CylinderGeometry æ¨¡æ“¬ n è§’æŸ±
  const geom = new THREE.CylinderGeometry(1.0, 1.0, 1.8, n, 1, false);
  const mat  = new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.35, metalness:0.1});
  const m = new THREE.Mesh(geom, mat);
  return m;
}

function makePyramid(n){
  // ç”¨ ConeGeometry æ¨¡æ“¬ n è§’éŒï¼ˆåº•ç‚º n é‚Šå½¢ï¼‰
  const geom = new THREE.ConeGeometry(1.1, 2.1, n, 1, false);
  const mat  = new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.35, metalness:0.1});
  const m = new THREE.Mesh(geom, mat);
  return m;
}

function setShape3D(n, type){
  if(mesh) scene.remove(mesh);
  mesh = (type==="pyramid") ? makePyramid(n) : makePrism(n);
  mesh.position.y = 0.1;
  scene.add(mesh);
  controls.target.set(0,0.1,0);
  controls.update();
}

function resize(){
  const wrap = document.getElementById("canvasWrap");
  const w = wrap.clientWidth;
  const h = wrap.clientHeight;
  renderer.setSize(w, h, false);
  camera.aspect = w/h;
  camera.updateProjectionMatrix();
}
window.addEventListener("resize", resize);

function animate(){
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}
resize();
animate();

/** =========================
 *  UIï¼šå»ºç«‹å­—å¡
 *  ========================= */
function clearGroups(){
  els.groupA.innerHTML = "";
  els.groupB.innerHTML = "";
  els.groupC.innerHTML = "";
  els.groupD.innerHTML = "";
}

function makeOptionButton(groupKey, text){
  const b = document.createElement("div");
  b.className = "opt";
  b.textContent = text;
  b.onclick = () => {
    // å¦‚æœå·²é€šé—œé–ä½å¯è‡ªè¡ŒåŠ 
    selected[groupKey] = text;
    // æ›´æ–°è©²çµ„é¸ä¸­ç‹€æ…‹
    const groupEl = (groupKey==="A"?els.groupA:groupKey==="B"?els.groupB:groupKey==="C"?els.groupC:els.groupD);
    [...groupEl.children].forEach(ch => ch.classList.toggle("selected", ch.textContent===text));
    updateSubmitState();
  };
  return b;
}

function updateSubmitState(){
  const ok = selected.A && selected.B && selected.C && selected.D;
  els.submit.disabled = !ok;
  els.pickHint.textContent = ok ? "å·²é¸å››é¡ï¼Œå¯ä»¥æäº¤" : "å››é¡éƒ½è¦æ€å…ˆå¯æäº¤";
}

function resetSelection(){
  selected = {A:null,B:null,C:null,D:null};
  document.querySelectorAll(".opt").forEach(o => o.classList.remove("selected"));
  updateSubmitState();
  els.status.className = "status";
  els.status.textContent = "æç¤ºï¼šç”¨æ»‘é¼ æ‹–æ‹‰å¯æ—‹è½‰ï¼Œæ»¾è¼ªå¯ç¸®æ”¾ï¼ˆæ‰‹æ©Ÿå¯å–®æŒ‡æ‹–æ‹‰ï¼‰ã€‚";
}

function buildCardsForCurrent(){
  const {n, type} = current;
  clearGroups();
  resetSelection();

  // æ­£ç¢ºç­”æ¡ˆ
  const ansA = solidTypeLabel(type);
  const ansB = lateralFaceLabel(type);
  const ansC = `å®ƒç¸½å…±æœ‰ï¼ˆ${facesCount(n,type)}ï¼‰å€‹é¢`;
  const ansD = `å®ƒçš„åå­—æ˜¯ï¼ˆ${shapeName(n,type)}ï¼‰`;

  // A é¡ï¼ˆå›ºå®šå…©å¼µï¼‰
  const optsA = shuffle(["å®ƒæ˜¯æŸ±é«”","å®ƒæ˜¯éŒ"]);
  optsA.forEach(t => els.groupA.appendChild(makeOptionButton("A", t)));

  // B é¡ï¼ˆå›ºå®šå…©å¼µï¼‰
  const optsB = shuffle(["å®ƒçš„å´é¢æ˜¯ä¸‰è§’å½¢","å®ƒçš„å´é¢æ˜¯å››é‚Šå½¢"]);
  optsB.forEach(t => els.groupB.appendChild(makeOptionButton("B", t)));

  // C é¡ï¼ˆé¢æ•¸ï¼š1 æ­£ç¢º + 2 å¹²æ“¾ï¼‰
  const correctFace = facesCount(n,type);
  const facesPool = [];
  uniquePush(facesPool, correctFace);

  // å¹²æ“¾ï¼šå¾å…¶ä»–åœ–å½¢æŠ½é¢æ•¸ï¼Œé¿å…å¤ªé›¢è­œäº¦é¿å…é‡è¦†
  while(facesPool.length < 3){
    const n2 = sampleOne(POLY_N);
    const t2 = sampleOne(TYPES);
    const f2 = facesCount(n2, t2);
    if(f2 !== correctFace) uniquePush(facesPool, f2);
  }
  const optsC = shuffle(facesPool.map(v => `å®ƒç¸½å…±æœ‰ï¼ˆ${v}ï¼‰å€‹é¢`));
  optsC.forEach(t => els.groupC.appendChild(makeOptionButton("C", t)));

  // D é¡ï¼ˆåå­—ï¼š1 æ­£ç¢º + 3 å¹²æ“¾ï¼‰
  const namesPool = [];
  uniquePush(namesPool, shapeName(n,type));
  while(namesPool.length < 4){
    const n2 = sampleOne(POLY_N);
    const t2 = sampleOne(TYPES);
    const nm = shapeName(n2,t2);
    if(nm !== shapeName(n,type)) uniquePush(namesPool, nm);
  }
  const optsD = shuffle(namesPool.map(v => `å®ƒçš„åå­—æ˜¯ï¼ˆ${v}ï¼‰`));
  optsD.forEach(t => els.groupD.appendChild(makeOptionButton("D", t)));

  // å­˜èµ·æ­£ç¢ºç­”æ¡ˆæ–¹ä¾¿æ ¸å°
  current.answers = {A:ansA,B:ansB,C:ansC,D:ansD};

  // Meta
  els.meta.textContent = `æœ¬é—œåœ–å½¢ï¼š${shapeName(n,type)}ï¼ˆè«‹é…å° 4 é¡å­—å¡ï¼‰`;
}

/** =========================
 *  å‡ºé¡Œ / æäº¤åˆ¤æ–·
 *  ========================= */
function newQuestion(){
  const n = sampleOne(POLY_N);
  const type = sampleOne(TYPES);
  current = {n, type, answers:null};

  total += 1;
  els.score.textContent = `å·²é€šé—œï¼š${cleared}ã€€ï½œã€€ç¸½é¡Œæ•¸ï¼š${total}`;

  setShape3D(n, type);
  buildCardsForCurrent();
}
function submit(){
  if(!current?.answers) return;

  const wrong = [];
  if(selected.A !== current.answers.A) wrong.push("Aï¼ˆæŸ±é«”ï¼éŒï¼‰");
  if(selected.B !== current.answers.B) wrong.push("Bï¼ˆå´é¢å½¢ç‹€ï¼‰");
  if(selected.C !== current.answers.C) wrong.push("Cï¼ˆç¸½é¢æ•¸ï¼‰");
  if(selected.D !== current.answers.D) wrong.push("Dï¼ˆåå­—ï¼‰");

  if(wrong.length === 0){
    cleared += 1;
    els.score.textContent = `å·²é€šé—œï¼š${cleared}ã€€ï½œã€€ç¸½é¡Œæ•¸ï¼š${total}`;
    els.status.className = "status good";
    els.status.textContent = "ğŸ‰ é€šé—œæˆåŠŸï¼å››é¡éƒ½é…å°æ­£ç¢ºã€‚ä½ å¯ä»¥æŒ‰ã€Œä¸‹ä¸€é¡Œã€å†ç©ã€‚";
  }else{
    els.status.className = "status bad";
    els.status.textContent = `æœªé€šé—œï¼šä»¥ä¸‹é¡åˆ¥æœªé…å°æ­£ç¢º â†’ ${wrong.join("ã€")}ã€‚è«‹å†è©¦ã€‚`;
  }
}

els.submit.addEventListener("click", submit);
els.newBtn.addEventListener("click", newQuestion);
els.resetBtn.addEventListener("click", resetSelection);

// é€²å…¥ç¬¬ä¸€é¡Œ
newQuestion();
</script>
</body>
</html>
